<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en-US">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.9.8"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Zephyr C++ Toolkit: zct::EventThread&lt; EventType &gt; Class Template Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectalign">
   <div id="projectname">Zephyr C++ Toolkit
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.8 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search/",'.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */
</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(document).ready(function(){initNavTree('classzct_1_1EventThread.html',''); initResizable(); });
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Loading...</div>
<div class="SRStatus" id="Searching">Searching...</div>
<div class="SRStatus" id="NoMatches">No Matches</div>
</div>
</div>
</div>
</div>

<div class="header">
  <div class="summary">
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pro-methods">Protected Member Functions</a> &#124;
<a href="#pro-static-methods">Static Protected Member Functions</a> &#124;
<a href="#pro-attribs">Protected Attributes</a> &#124;
<a href="classzct_1_1EventThread-members.html">List of all members</a>  </div>
  <div class="headertitle"><div class="title">zct::EventThread&lt; EventType &gt; Class Template Reference</div></div>
</div><!--header-->
<div class="contents">

<p>Use this class in your objects to create a thread that can wait for events.  
 <a href="classzct_1_1EventThread.html#details">More...</a></p>

<p><code>#include &lt;<a class="el" href="EventThread_8hpp_source.html">EventThread.hpp</a>&gt;</code></p>
<div class="dynheader">
Collaboration diagram for zct::EventThread&lt; EventType &gt;:</div>
<div class="dyncontent">
<div class="center"><img src="classzct_1_1EventThread__coll__graph.png" border="0" usemap="#azct_1_1EventThread_3_01EventType_01_4_coll__map" alt="Collaboration graph"/></div>
<map name="azct_1_1EventThread_3_01EventType_01_4_coll__map" id="azct_1_1EventThread_3_01EventType_01_4_coll__map">
<area shape="rect" title="Use this class in your objects to create a thread that can wait for events." alt="" coords="5,181,233,207"/>
<area shape="rect" href="classzct_1_1TimerManager.html" title=" " alt="" coords="47,93,191,119"/>
<area shape="poly" title=" " alt="" coords="122,133,122,181,117,181,117,133"/>
<area shape="rect" href="classzct_1_1Timer.html" title="A timer that can be used to execute callbacks at regular intervals in an event driven application." alt="" coords="76,5,163,31"/>
<area shape="poly" title=" " alt="" coords="122,45,122,93,117,93,117,45"/>
</map>
<center><span class="legend">[<a target="top" href="graph_legend.html">legend</a>]</span></center></div>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pub-methods" name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:a4751223fb4a4b628988433c0f415892f" id="r_a4751223fb4a4b628988433c0f415892f"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classzct_1_1EventThread.html#a4751223fb4a4b628988433c0f415892f">EventThread</a> (const char *name, k_thread_stack_t *threadStack, size_t threadStackSize, int threadPriority, size_t eventQueueBufferNumItems)</td></tr>
<tr class="separator:a4751223fb4a4b628988433c0f415892f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a904626047be03e08a6563cdafb3582c0" id="r_a904626047be03e08a6563cdafb3582c0"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classzct_1_1EventThread.html#a904626047be03e08a6563cdafb3582c0">~EventThread</a> ()</td></tr>
<tr class="separator:a904626047be03e08a6563cdafb3582c0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aab7247827f4989207fc613d8b4495219" id="r_aab7247827f4989207fc613d8b4495219"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classzct_1_1EventThread.html#aab7247827f4989207fc613d8b4495219">start</a> ()</td></tr>
<tr class="separator:aab7247827f4989207fc613d8b4495219"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a466b293455fda762c63357549025d8af" id="r_a466b293455fda762c63357549025d8af"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classzct_1_1EventThread.html#a466b293455fda762c63357549025d8af">onExternalEvent</a> (std::function&lt; void(const EventType &amp;)&gt; callback)</td></tr>
<tr class="separator:a466b293455fda762c63357549025d8af"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6eda66c2494c12922204a368786dfb73" id="r_a6eda66c2494c12922204a368786dfb73"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classzct_1_1EventThread.html#a6eda66c2494c12922204a368786dfb73">sendEvent</a> (const EventType &amp;event)</td></tr>
<tr class="separator:a6eda66c2494c12922204a368786dfb73"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa5461d18e52c82257da77a557f173e24" id="r_aa5461d18e52c82257da77a557f173e24"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classzct_1_1TimerManager.html">TimerManager</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classzct_1_1EventThread.html#aa5461d18e52c82257da77a557f173e24">timerManager</a> ()</td></tr>
<tr class="separator:aa5461d18e52c82257da77a557f173e24"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a491f2b0619e3db842d9f40f1b268f892" id="r_a491f2b0619e3db842d9f40f1b268f892"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classzct_1_1EventThread.html#a491f2b0619e3db842d9f40f1b268f892">exitEventLoop</a> ()</td></tr>
<tr class="separator:a491f2b0619e3db842d9f40f1b268f892"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pro-methods" name="pro-methods"></a>
Protected Member Functions</h2></td></tr>
<tr class="memitem:a7edd0a4e156e57bf8f3c6832ae3bde68" id="r_a7edd0a4e156e57bf8f3c6832ae3bde68"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classzct_1_1EventThread.html#a7edd0a4e156e57bf8f3c6832ae3bde68">runEventLoop</a> ()</td></tr>
<tr class="separator:a7edd0a4e156e57bf8f3c6832ae3bde68"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pro-static-methods" name="pro-static-methods"></a>
Static Protected Member Functions</h2></td></tr>
<tr class="memitem:ad9ef1d2f6b589be97f8a27c632278d2b" id="r_ad9ef1d2f6b589be97f8a27c632278d2b"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classzct_1_1EventThread.html#ad9ef1d2f6b589be97f8a27c632278d2b">staticThreadFunction</a> (void *arg1, void *arg2, void *arg3)</td></tr>
<tr class="separator:ad9ef1d2f6b589be97f8a27c632278d2b"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pro-attribs" name="pro-attribs"></a>
Protected Attributes</h2></td></tr>
<tr class="memitem:a2445c0ef143d1ecece52db6354c1a3c6" id="r_a2445c0ef143d1ecece52db6354c1a3c6"><td class="memItemLeft" align="right" valign="top">const char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classzct_1_1EventThread.html#a2445c0ef143d1ecece52db6354c1a3c6">m_name</a> = nullptr</td></tr>
<tr class="separator:a2445c0ef143d1ecece52db6354c1a3c6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a63d260fa7951c1731953b2f89cb8c794" id="r_a63d260fa7951c1731953b2f89cb8c794"><td class="memItemLeft" align="right" valign="top">void *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classzct_1_1EventThread.html#a63d260fa7951c1731953b2f89cb8c794">m_eventQueueBuffer</a> = nullptr</td></tr>
<tr class="separator:a63d260fa7951c1731953b2f89cb8c794"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae99f50e4328cdd741e63e379fbe7de6a" id="r_ae99f50e4328cdd741e63e379fbe7de6a"><td class="memItemLeft" align="right" valign="top">struct k_thread&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classzct_1_1EventThread.html#ae99f50e4328cdd741e63e379fbe7de6a">m_thread</a></td></tr>
<tr class="separator:ae99f50e4328cdd741e63e379fbe7de6a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aeac1a315e79be599f6c6c8e275c7286a" id="r_aeac1a315e79be599f6c6c8e275c7286a"><td class="memItemLeft" align="right" valign="top">struct k_msgq&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classzct_1_1EventThread.html#aeac1a315e79be599f6c6c8e275c7286a">m_threadMsgQueue</a></td></tr>
<tr class="separator:aeac1a315e79be599f6c6c8e275c7286a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afb9f2928abd9d6ec21353c13828ec800" id="r_afb9f2928abd9d6ec21353c13828ec800"><td class="memItemLeft" align="right" valign="top">k_thread_stack_t *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classzct_1_1EventThread.html#afb9f2928abd9d6ec21353c13828ec800">m_threadStack</a></td></tr>
<tr class="separator:afb9f2928abd9d6ec21353c13828ec800"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a35d26c4ac62b589f1fbd63fb43e95728" id="r_a35d26c4ac62b589f1fbd63fb43e95728"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classzct_1_1EventThread.html#a35d26c4ac62b589f1fbd63fb43e95728">m_threadStackSize</a></td></tr>
<tr class="separator:a35d26c4ac62b589f1fbd63fb43e95728"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a601678c8b320abfdb4670c914880556c" id="r_a601678c8b320abfdb4670c914880556c"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classzct_1_1EventThread.html#a601678c8b320abfdb4670c914880556c">m_threadPriority</a></td></tr>
<tr class="separator:a601678c8b320abfdb4670c914880556c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af22edf13ee45ca97df31199cdd089f7a" id="r_af22edf13ee45ca97df31199cdd089f7a"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classzct_1_1TimerManager.html">TimerManager</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classzct_1_1EventThread.html#af22edf13ee45ca97df31199cdd089f7a">m_timerManager</a></td></tr>
<tr class="separator:af22edf13ee45ca97df31199cdd089f7a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aec687dd8872426f1aad685703922a2e0" id="r_aec687dd8872426f1aad685703922a2e0"><td class="memItemLeft" align="right" valign="top">std::function&lt; void(const EventType &amp;)&gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classzct_1_1EventThread.html#aec687dd8872426f1aad685703922a2e0">m_externalEventCallback</a> = nullptr</td></tr>
<tr class="separator:aec687dd8872426f1aad685703922a2e0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afdfe877db96d4deef20cc96f6673c84a" id="r_afdfe877db96d4deef20cc96f6673c84a"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classzct_1_1EventThread.html#afdfe877db96d4deef20cc96f6673c84a">m_exitEventLoop</a> = false</td></tr>
<tr class="separator:afdfe877db96d4deef20cc96f6673c84a"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><div class="compoundTemplParams">template&lt;typename EventType&gt;<br />
class zct::EventThread&lt; EventType &gt;</div><p>Use this class in your objects to create a thread that can wait for events. </p>
<p>This class spawns a new Zephyr thread.</p>
<p>The user is responsible for making sure the thread function returns if you want to destroy this object. This is because the destructor blocks until the thread is complete. The best way to do this is to implement a exit event and send it to the event thread. The event thread returns when it receives the exit event.</p>
<p>Making sure to return from the thread function is only important if you are destroying the object, e.g. in testing.</p>
<p>This class works really well with event driven programming and hierarchical state machines (HSM) like NinjaHSM.</p>
<p>Below is an example of how to use this class.</p>
<div class="fragment"><div class="line"><span class="preprocessor">#include &lt;variant&gt;</span></div>
<div class="line"> </div>
<div class="line"><span class="preprocessor">#include &lt;zephyr/kernel.h&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;zephyr/logging/log.h&gt;</span></div>
<div class="line"> </div>
<div class="line"><span class="preprocessor">#include &quot;<a class="code" href="EventThread_8hpp.html">ZephyrCppToolkit/Events/EventThread.hpp</a>&quot;</span></div>
<div class="line"> </div>
<div class="line"><a class="code hl_function" href="namespacezct.html#a03e785beb455af4012d3a57e19c99d13">LOG_MODULE_REGISTER</a>(EventThreadTests, LOG_LEVEL_DBG);</div>
<div class="line"> </div>
<div class="line"><span class="comment">//================================================================================================//</span></div>
<div class="line"><span class="comment">// EVENTS</span></div>
<div class="line"><span class="comment">//================================================================================================//</span></div>
<div class="line"> </div>
<div class="line"><span class="keyword">namespace </span>Events {</div>
<div class="line"> </div>
<div class="line"><span class="keyword">struct </span>Exit {};</div>
<div class="line"> </div>
<div class="line"><span class="keyword">struct </span>LedFlashing {</div>
<div class="line">    uint32_t flashRateMs;</div>
<div class="line">};</div>
<div class="line"> </div>
<div class="line"><span class="keyword">struct </span>TimerExpired {};</div>
<div class="line"> </div>
<div class="line"><span class="comment">// Create a generic event type that can be anyone of the specific events above.</span></div>
<div class="line"><span class="keyword">typedef</span> std::variant&lt;LedFlashing, Exit, TimerExpired&gt; Generic;</div>
<div class="line"> </div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line"><span class="comment">//================================================================================================//</span></div>
<div class="line"><span class="comment">// EVENT THREAD</span></div>
<div class="line"><span class="comment">//================================================================================================//</span></div>
<div class="line"> </div>
<div class="line"><span class="keyword">class </span>Led {</div>
<div class="line"><span class="keyword">public</span>:</div>
<div class="line">    Led() :</div>
<div class="line">        m_eventThread(</div>
<div class="line">            <span class="stringliteral">&quot;Led&quot;</span>,</div>
<div class="line">            m_threadStack,</div>
<div class="line">            THREAD_STACK_SIZE,</div>
<div class="line">            7,</div>
<div class="line">            EVENT_QUEUE_NUM_ITEMS</div>
<div class="line">        ),</div>
<div class="line">        m_flashingTimer(<span class="stringliteral">&quot;FlashingTimer&quot;</span>, [this]() {</div>
<div class="line">            Events::TimerExpired timerExpiredEvent;</div>
<div class="line">            handleEvent(timerExpiredEvent);</div>
<div class="line">        })</div>
<div class="line">    {</div>
<div class="line">        <span class="comment">// Register timers</span></div>
<div class="line">        m_eventThread.timerManager().registerTimer(m_flashingTimer);</div>
<div class="line">        </div>
<div class="line">        <span class="comment">// Register external event callback</span></div>
<div class="line">        m_eventThread.onExternalEvent([<span class="keyword">this</span>](<span class="keyword">const</span> Events::Generic&amp; event) {</div>
<div class="line">            handleEvent(event);</div>
<div class="line">        });</div>
<div class="line">        </div>
<div class="line">        <span class="comment">// Start the event loop (it runs it it&#39;s own thread)</span></div>
<div class="line">        m_eventThread.start();</div>
<div class="line">    }</div>
<div class="line"> </div>
<div class="line">    ~Led() {</div>
<div class="line">        <span class="comment">// Send the exit event to the event thread</span></div>
<div class="line">        Events::Exit exitEvent;</div>
<div class="line">        m_eventThread.sendEvent(exitEvent);</div>
<div class="line">    }</div>
<div class="line"> </div>
<div class="line">    <span class="keywordtype">void</span> flash(uint32_t flashRateMs) {</div>
<div class="line">        Events::LedFlashing ledFlashingEvent = { .flashRateMs = flashRateMs };</div>
<div class="line">        <span class="comment">// This is how use send &quot;external&quot; events (i.e. not timer events) to</span></div>
<div class="line">        <span class="comment">// the event thread. The event thread will call handleEvent() when it</span></div>
<div class="line">        <span class="comment">// receives this event.</span></div>
<div class="line">        m_eventThread.sendEvent(ledFlashingEvent);</div>
<div class="line">    }</div>
<div class="line"> </div>
<div class="line"><span class="keyword">private</span>:</div>
<div class="line">    <span class="keyword">static</span> <span class="keyword">constexpr</span> <span class="keywordtype">size_t</span> EVENT_QUEUE_NUM_ITEMS = 10;</div>
<div class="line">    <span class="keyword">static</span> <span class="keyword">constexpr</span> <span class="keywordtype">size_t</span> THREAD_STACK_SIZE = 512;</div>
<div class="line">    K_KERNEL_STACK_MEMBER(m_threadStack, THREAD_STACK_SIZE);</div>
<div class="line">    <a class="code hl_class" href="classzct_1_1EventThread.html">zct::EventThread&lt;Events::Generic&gt;</a> m_eventThread;</div>
<div class="line">    <a class="code hl_class" href="classzct_1_1Timer.html">zct::Timer</a> m_flashingTimer;</div>
<div class="line">    <span class="keywordtype">bool</span> m_ledIsOn = <span class="keyword">false</span>;</div>
<div class="line"> </div>
<div class="line">    <span class="keywordtype">void</span> handleEvent(<span class="keyword">const</span> Events::Generic&amp; event) {</div>
<div class="line">        <span class="keywordflow">if</span> (std::holds_alternative&lt;Events::LedFlashing&gt;(event)) {</div>
<div class="line">            <span class="comment">// Start the timer to flash the LED</span></div>
<div class="line">            m_flashingTimer.<a class="code hl_function" href="classzct_1_1Timer.html#ac98b8c2905ad49b083265b9da5b8a750">start</a>(1000, 1000);</div>
<div class="line">            LOG_INF(<span class="stringliteral">&quot;Starting flashing. Turning LED on...&quot;</span>);</div>
<div class="line">            m_ledIsOn = <span class="keyword">true</span>;</div>
<div class="line">        } <span class="keywordflow">else</span> <span class="keywordflow">if</span> (std::holds_alternative&lt;Events::Exit&gt;(event)) {</div>
<div class="line">            <span class="comment">// This will cause the event loop to end (and the thread to exit)</span></div>
<div class="line">            <span class="comment">// once we return from handleEvent().</span></div>
<div class="line">            m_eventThread.<a class="code hl_function" href="classzct_1_1EventThread.html#a491f2b0619e3db842d9f40f1b268f892">exitEventLoop</a>();</div>
<div class="line">        } <span class="keywordflow">else</span> <span class="keywordflow">if</span> (std::holds_alternative&lt;Events::TimerExpired&gt;(event)) {</div>
<div class="line">            LOG_INF(<span class="stringliteral">&quot;Toggling LED to %d.&quot;</span>, !m_ledIsOn);</div>
<div class="line">            m_ledIsOn = !m_ledIsOn;</div>
<div class="line">        }</div>
<div class="line">    }</div>
<div class="line">};</div>
<div class="line"> </div>
<div class="line"><span class="keywordtype">int</span> main() {</div>
<div class="line">    Led led;</div>
<div class="line"> </div>
<div class="line">    <span class="comment">// Start the LED flashing. The flashing will happen</span></div>
<div class="line">    <span class="comment">// in the LED event thread.</span></div>
<div class="line">    led.flash(1000);</div>
<div class="line"> </div>
<div class="line">    <span class="comment">// Wait 2.5s. The LED should flash twice in this time.</span></div>
<div class="line">    k_sleep(K_MSEC(2500));</div>
<div class="line">}</div>
<div class="ttc" id="aEventThread_8hpp_html"><div class="ttname"><a href="EventThread_8hpp.html">EventThread.hpp</a></div></div>
<div class="ttc" id="aclasszct_1_1EventThread_html"><div class="ttname"><a href="classzct_1_1EventThread.html">zct::EventThread</a></div><div class="ttdoc">Use this class in your objects to create a thread that can wait for events.</div><div class="ttdef"><b>Definition</b> EventThread.hpp:36</div></div>
<div class="ttc" id="aclasszct_1_1EventThread_html_a491f2b0619e3db842d9f40f1b268f892"><div class="ttname"><a href="classzct_1_1EventThread.html#a491f2b0619e3db842d9f40f1b268f892">zct::EventThread::exitEventLoop</a></div><div class="ttdeci">void exitEventLoop()</div><div class="ttdef"><b>Definition</b> EventThread.hpp:168</div></div>
<div class="ttc" id="aclasszct_1_1Timer_html"><div class="ttname"><a href="classzct_1_1Timer.html">zct::Timer</a></div><div class="ttdoc">A timer that can be used to execute callbacks at regular intervals in an event driven application.</div><div class="ttdef"><b>Definition</b> Timer.hpp:39</div></div>
<div class="ttc" id="aclasszct_1_1Timer_html_ac98b8c2905ad49b083265b9da5b8a750"><div class="ttname"><a href="classzct_1_1Timer.html#ac98b8c2905ad49b083265b9da5b8a750">zct::Timer::start</a></div><div class="ttdeci">void start(int64_t period_ms)</div><div class="ttdef"><b>Definition</b> Timer.hpp:63</div></div>
<div class="ttc" id="anamespacezct_html_a03e785beb455af4012d3a57e19c99d13"><div class="ttname"><a href="namespacezct.html#a03e785beb455af4012d3a57e19c99d13">zct::LOG_MODULE_REGISTER</a></div><div class="ttdeci">LOG_MODULE_REGISTER(EventThread, LOG_LEVEL_DBG)</div></div>
</div><!-- fragment --> </div><h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a id="a4751223fb4a4b628988433c0f415892f" name="a4751223fb4a4b628988433c0f415892f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4751223fb4a4b628988433c0f415892f">&#9670;&#160;</a></span>EventThread()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename EventType &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classzct_1_1EventThread.html">zct::EventThread</a>&lt; EventType &gt;::EventThread </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">k_thread_stack_t *&#160;</td>
          <td class="paramname"><em>threadStack</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>threadStackSize</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>threadPriority</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>eventQueueBufferNumItems</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Create a new event thread.</p>
<p>Dynamically allocates memory for the event queue buffer. At the moment, you have to allocate the thread stack yourself and pass it in. Once Zephyr's dynamic thread support is out of experimental (and working), hopefully we can just pass in the desired stack size.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">name</td><td>The name of the this event thread. Used for logging purposes. The Zephyr thread name will also be set to this name. </td></tr>
    <tr><td class="paramname">threadStack</td><td>The stack to use for the thread. You can use <code>K_KERNEL_STACK_MEMBER(m_threadStack, THREAD_STACK_SIZE);</code> to declare a stack member in the parent class that encloses this event thread. </td></tr>
    <tr><td class="paramname">threadStackSize</td><td>The size of the stack provided. </td></tr>
    <tr><td class="paramname">threadPriority</td><td>The priority to assign to the thread. </td></tr>
    <tr><td class="paramname">eventQueueBufferNumItems</td><td>The number of items in the event queue. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a904626047be03e08a6563cdafb3582c0" name="a904626047be03e08a6563cdafb3582c0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a904626047be03e08a6563cdafb3582c0">&#9670;&#160;</a></span>~EventThread()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename EventType &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classzct_1_1EventThread.html">zct::EventThread</a>&lt; EventType &gt;::~<a class="el" href="classzct_1_1EventThread.html">EventThread</a> </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Destroy the event thread. This will block until the thread has exited.</p>
<p>If you want this function to return, make sure the event loop exits. The best way to do this is to call <a class="el" href="classzct_1_1EventThread.html#a491f2b0619e3db842d9f40f1b268f892">exitEventLoop()</a> from a timer callback or external event handler. </p>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a id="a491f2b0619e3db842d9f40f1b268f892" name="a491f2b0619e3db842d9f40f1b268f892"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a491f2b0619e3db842d9f40f1b268f892">&#9670;&#160;</a></span>exitEventLoop()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename EventType &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classzct_1_1EventThread.html">zct::EventThread</a>&lt; EventType &gt;::exitEventLoop </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Exit the event loop. This will cause <a class="el" href="classzct_1_1EventThread.html#a7edd0a4e156e57bf8f3c6832ae3bde68">runEventLoop()</a> to return. This function must be called from the event thread context (i.e. from a timer callback or from an external event handler).</p>
<p>This will make the event loop return from <a class="el" href="classzct_1_1EventThread.html#a7edd0a4e156e57bf8f3c6832ae3bde68">runEventLoop()</a> as soon as the timer callback or external event handler returns.</p>
<p>Use this in tests to cleanly exit from the event loop and it's corresponding thread. </p>

</div>
</div>
<a id="a466b293455fda762c63357549025d8af" name="a466b293455fda762c63357549025d8af"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a466b293455fda762c63357549025d8af">&#9670;&#160;</a></span>onExternalEvent()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename EventType &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classzct_1_1EventThread.html">zct::EventThread</a>&lt; EventType &gt;::onExternalEvent </td>
          <td>(</td>
          <td class="paramtype">std::function&lt; void(const EventType &amp;)&gt;&#160;</td>
          <td class="paramname"><em>callback</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Set the callback function to be called when external events are received.</p>
<p>The callback is executed in the context of the event thread.</p>
<p>This function should be used to setup the external event callback before <a class="el" href="classzct_1_1EventThread.html#aab7247827f4989207fc613d8b4495219">start()</a> is called to start the event loop.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">callback</td><td>The callback function to call when an external event is received. The callback will be passed the received event. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a7edd0a4e156e57bf8f3c6832ae3bde68" name="a7edd0a4e156e57bf8f3c6832ae3bde68"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7edd0a4e156e57bf8f3c6832ae3bde68">&#9670;&#160;</a></span>runEventLoop()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename EventType &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classzct_1_1EventThread.html">zct::EventThread</a>&lt; EventType &gt;::runEventLoop </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Start the event loop. This function never returns and should be called from the thread function that is passed in to the constructor.</p>
<p>This function will:</p><ul>
<li>Handle expired timers by calling their callbacks</li>
<li>Handle external events by calling the registered external event callback (call <a class="el" href="classzct_1_1EventThread.html#a466b293455fda762c63357549025d8af">onExternalEvent()</a> to register a callback).</li>
</ul>
<p>This should be called from the thread function that is passed in to the constructor, once any initialisation you want done (e.g. setup some timers) has been done. </p>

</div>
</div>
<a id="a6eda66c2494c12922204a368786dfb73" name="a6eda66c2494c12922204a368786dfb73"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6eda66c2494c12922204a368786dfb73">&#9670;&#160;</a></span>sendEvent()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename EventType &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classzct_1_1EventThread.html">zct::EventThread</a>&lt; EventType &gt;::sendEvent </td>
          <td>(</td>
          <td class="paramtype">const EventType &amp;&#160;</td>
          <td class="paramname"><em>event</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Send an event to this event thread. This can be called from any other thread to send an event to this event thread.</p>
<dl class="section note"><dt>Note</dt><dd>This function is thread safe. </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">event</td><td>The event to send. It is copied into the event queue so it's lifetime only needs to be as long as this function call. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="aab7247827f4989207fc613d8b4495219" name="aab7247827f4989207fc613d8b4495219"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aab7247827f4989207fc613d8b4495219">&#9670;&#160;</a></span>start()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename EventType &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classzct_1_1EventThread.html">zct::EventThread</a>&lt; EventType &gt;::start </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Start the event thread. This creates and starts the Zephyr thread which will begin running the event loop.</p>
<p>This should be called after the constructor and after any setup (like registering timers) has been completed. </p>

</div>
</div>
<a id="ad9ef1d2f6b589be97f8a27c632278d2b" name="ad9ef1d2f6b589be97f8a27c632278d2b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad9ef1d2f6b589be97f8a27c632278d2b">&#9670;&#160;</a></span>staticThreadFunction()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename EventType &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void <a class="el" href="classzct_1_1EventThread.html">zct::EventThread</a>&lt; EventType &gt;::staticThreadFunction </td>
          <td>(</td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>arg1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>arg2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>arg3</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>The function needed by pass to Zephyr's thread API </p>

</div>
</div>
<a id="aa5461d18e52c82257da77a557f173e24" name="aa5461d18e52c82257da77a557f173e24"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa5461d18e52c82257da77a557f173e24">&#9670;&#160;</a></span>timerManager()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename EventType &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classzct_1_1TimerManager.html">TimerManager</a> &amp; <a class="el" href="classzct_1_1EventThread.html">zct::EventThread</a>&lt; EventType &gt;::timerManager </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Call to get the timer manager for this event thread. This is useful when you want to create timers and then register them with the event thread.</p>
<p>Typically you would call:</p>
<div class="fragment"><div class="line">myEventThread.timerManager().registerTimer(myTimer);</div>
</div><!-- fragment --><dl class="section return"><dt>Returns</dt><dd>A reference to the timer manager for this event thread. </dd></dl>

</div>
</div>
<h2 class="groupheader">Member Data Documentation</h2>
<a id="a63d260fa7951c1731953b2f89cb8c794" name="a63d260fa7951c1731953b2f89cb8c794"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a63d260fa7951c1731953b2f89cb8c794">&#9670;&#160;</a></span>m_eventQueueBuffer</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename EventType &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void* <a class="el" href="classzct_1_1EventThread.html">zct::EventThread</a>&lt; EventType &gt;::m_eventQueueBuffer = nullptr</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="afdfe877db96d4deef20cc96f6673c84a" name="afdfe877db96d4deef20cc96f6673c84a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afdfe877db96d4deef20cc96f6673c84a">&#9670;&#160;</a></span>m_exitEventLoop</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename EventType &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classzct_1_1EventThread.html">zct::EventThread</a>&lt; EventType &gt;::m_exitEventLoop = false</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Used to signal from <a class="el" href="classzct_1_1EventThread.html#a491f2b0619e3db842d9f40f1b268f892">exitEventLoop()</a> to the code in the <a class="el" href="classzct_1_1EventThread.html#a7edd0a4e156e57bf8f3c6832ae3bde68">runEventLoop()</a> function to exit. </p>

</div>
</div>
<a id="aec687dd8872426f1aad685703922a2e0" name="aec687dd8872426f1aad685703922a2e0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aec687dd8872426f1aad685703922a2e0">&#9670;&#160;</a></span>m_externalEventCallback</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename EventType &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::function&lt;void(const EventType&amp;)&gt; <a class="el" href="classzct_1_1EventThread.html">zct::EventThread</a>&lt; EventType &gt;::m_externalEventCallback = nullptr</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a2445c0ef143d1ecece52db6354c1a3c6" name="a2445c0ef143d1ecece52db6354c1a3c6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2445c0ef143d1ecece52db6354c1a3c6">&#9670;&#160;</a></span>m_name</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename EventType &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const char* <a class="el" href="classzct_1_1EventThread.html">zct::EventThread</a>&lt; EventType &gt;::m_name = nullptr</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="ae99f50e4328cdd741e63e379fbe7de6a" name="ae99f50e4328cdd741e63e379fbe7de6a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae99f50e4328cdd741e63e379fbe7de6a">&#9670;&#160;</a></span>m_thread</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename EventType &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">struct k_thread <a class="el" href="classzct_1_1EventThread.html">zct::EventThread</a>&lt; EventType &gt;::m_thread</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="aeac1a315e79be599f6c6c8e275c7286a" name="aeac1a315e79be599f6c6c8e275c7286a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aeac1a315e79be599f6c6c8e275c7286a">&#9670;&#160;</a></span>m_threadMsgQueue</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename EventType &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">struct k_msgq <a class="el" href="classzct_1_1EventThread.html">zct::EventThread</a>&lt; EventType &gt;::m_threadMsgQueue</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a601678c8b320abfdb4670c914880556c" name="a601678c8b320abfdb4670c914880556c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a601678c8b320abfdb4670c914880556c">&#9670;&#160;</a></span>m_threadPriority</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename EventType &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int <a class="el" href="classzct_1_1EventThread.html">zct::EventThread</a>&lt; EventType &gt;::m_threadPriority</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="afb9f2928abd9d6ec21353c13828ec800" name="afb9f2928abd9d6ec21353c13828ec800"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afb9f2928abd9d6ec21353c13828ec800">&#9670;&#160;</a></span>m_threadStack</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename EventType &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">k_thread_stack_t* <a class="el" href="classzct_1_1EventThread.html">zct::EventThread</a>&lt; EventType &gt;::m_threadStack</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a35d26c4ac62b589f1fbd63fb43e95728" name="a35d26c4ac62b589f1fbd63fb43e95728"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a35d26c4ac62b589f1fbd63fb43e95728">&#9670;&#160;</a></span>m_threadStackSize</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename EventType &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">size_t <a class="el" href="classzct_1_1EventThread.html">zct::EventThread</a>&lt; EventType &gt;::m_threadStackSize</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="af22edf13ee45ca97df31199cdd089f7a" name="af22edf13ee45ca97df31199cdd089f7a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af22edf13ee45ca97df31199cdd089f7a">&#9670;&#160;</a></span>m_timerManager</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename EventType &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classzct_1_1TimerManager.html">TimerManager</a> <a class="el" href="classzct_1_1EventThread.html">zct::EventThread</a>&lt; EventType &gt;::m_timerManager</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<hr/>The documentation for this class was generated from the following file:<ul>
<li>/home/runner/work/ZephyrCppToolkit/ZephyrCppToolkit/include/ZephyrCppToolkit/Events/<a class="el" href="EventThread_8hpp_source.html">EventThread.hpp</a></li>
</ul>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="navelem"><a class="el" href="namespacezct.html">zct</a></li><li class="navelem"><a class="el" href="classzct_1_1EventThread.html">EventThread</a></li>
    <li class="footer">Generated by <a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.8 </li>
  </ul>
</div>
</body>
</html>
