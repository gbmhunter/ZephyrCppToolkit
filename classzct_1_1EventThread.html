<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en-US">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.9.8"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Zephyr C++ Toolkit: zct::EventThread&lt; EventType &gt; Class Template Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectalign">
   <div id="projectname">Zephyr C++ Toolkit
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.8 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search/",'.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */
</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(document).ready(function(){initNavTree('classzct_1_1EventThread.html',''); initResizable(); });
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Loading...</div>
<div class="SRStatus" id="Searching">Searching...</div>
<div class="SRStatus" id="NoMatches">No Matches</div>
</div>
</div>
</div>
</div>

<div class="header">
  <div class="summary">
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pro-static-methods">Static Protected Member Functions</a> &#124;
<a href="#pro-attribs">Protected Attributes</a> &#124;
<a href="classzct_1_1EventThread-members.html">List of all members</a>  </div>
  <div class="headertitle"><div class="title">zct::EventThread&lt; EventType &gt; Class Template Reference</div></div>
</div><!--header-->
<div class="contents">

<p>Use this class in your objects to create a thread that can wait for events.  
 <a href="classzct_1_1EventThread.html#details">More...</a></p>

<p><code>#include &lt;<a class="el" href="EventThread_8hpp_source.html">EventThread.hpp</a>&gt;</code></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pub-methods" name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:ae5fff68f935d3dc1b0a7043232b54eeb" id="r_ae5fff68f935d3dc1b0a7043232b54eeb"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classzct_1_1EventThread.html#ae5fff68f935d3dc1b0a7043232b54eeb">EventThread</a> (const char *name, k_thread_stack_t *threadStack, size_t threadStackSize, std::function&lt; void()&gt; threadFunction, int threadPriority, size_t eventQueueBufferNumItems)</td></tr>
<tr class="separator:ae5fff68f935d3dc1b0a7043232b54eeb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a904626047be03e08a6563cdafb3582c0" id="r_a904626047be03e08a6563cdafb3582c0"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classzct_1_1EventThread.html#a904626047be03e08a6563cdafb3582c0">~EventThread</a> ()</td></tr>
<tr class="separator:a904626047be03e08a6563cdafb3582c0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2607651cb659eb7d0c1beb81a7690293" id="r_a2607651cb659eb7d0c1beb81a7690293"><td class="memItemLeft" align="right" valign="top">EventType&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classzct_1_1EventThread.html#a2607651cb659eb7d0c1beb81a7690293">waitForEvent</a> ()</td></tr>
<tr class="separator:a2607651cb659eb7d0c1beb81a7690293"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6eda66c2494c12922204a368786dfb73" id="r_a6eda66c2494c12922204a368786dfb73"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classzct_1_1EventThread.html#a6eda66c2494c12922204a368786dfb73">sendEvent</a> (const EventType &amp;event)</td></tr>
<tr class="separator:a6eda66c2494c12922204a368786dfb73"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a62e7cf1cb3a1fe3fb0fd531d35493287" id="r_a62e7cf1cb3a1fe3fb0fd531d35493287"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classzct_1_1TimerManager.html">TimerManager</a>&lt; EventType &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classzct_1_1EventThread.html#a62e7cf1cb3a1fe3fb0fd531d35493287">timerManager</a> ()</td></tr>
<tr class="separator:a62e7cf1cb3a1fe3fb0fd531d35493287"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pro-static-methods" name="pro-static-methods"></a>
Static Protected Member Functions</h2></td></tr>
<tr class="memitem:ad9ef1d2f6b589be97f8a27c632278d2b" id="r_ad9ef1d2f6b589be97f8a27c632278d2b"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classzct_1_1EventThread.html#ad9ef1d2f6b589be97f8a27c632278d2b">staticThreadFunction</a> (void *arg1, void *arg2, void *arg3)</td></tr>
<tr class="separator:ad9ef1d2f6b589be97f8a27c632278d2b"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pro-attribs" name="pro-attribs"></a>
Protected Attributes</h2></td></tr>
<tr class="memitem:a2445c0ef143d1ecece52db6354c1a3c6" id="r_a2445c0ef143d1ecece52db6354c1a3c6"><td class="memItemLeft" align="right" valign="top">const char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classzct_1_1EventThread.html#a2445c0ef143d1ecece52db6354c1a3c6">m_name</a> = nullptr</td></tr>
<tr class="separator:a2445c0ef143d1ecece52db6354c1a3c6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a63d260fa7951c1731953b2f89cb8c794" id="r_a63d260fa7951c1731953b2f89cb8c794"><td class="memItemLeft" align="right" valign="top">void *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classzct_1_1EventThread.html#a63d260fa7951c1731953b2f89cb8c794">m_eventQueueBuffer</a> = nullptr</td></tr>
<tr class="separator:a63d260fa7951c1731953b2f89cb8c794"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae99f50e4328cdd741e63e379fbe7de6a" id="r_ae99f50e4328cdd741e63e379fbe7de6a"><td class="memItemLeft" align="right" valign="top">struct k_thread&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classzct_1_1EventThread.html#ae99f50e4328cdd741e63e379fbe7de6a">m_thread</a></td></tr>
<tr class="separator:ae99f50e4328cdd741e63e379fbe7de6a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aeac1a315e79be599f6c6c8e275c7286a" id="r_aeac1a315e79be599f6c6c8e275c7286a"><td class="memItemLeft" align="right" valign="top">struct k_msgq&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classzct_1_1EventThread.html#aeac1a315e79be599f6c6c8e275c7286a">m_threadMsgQueue</a></td></tr>
<tr class="separator:aeac1a315e79be599f6c6c8e275c7286a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af82899498638998526e3118fded52e0c" id="r_af82899498638998526e3118fded52e0c"><td class="memItemLeft" align="right" valign="top">std::function&lt; void()&gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classzct_1_1EventThread.html#af82899498638998526e3118fded52e0c">m_threadFunction</a></td></tr>
<tr class="separator:af82899498638998526e3118fded52e0c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac7f6b59b51793ee17b868ea32a3ae63d" id="r_ac7f6b59b51793ee17b868ea32a3ae63d"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classzct_1_1TimerManager.html">TimerManager</a>&lt; EventType &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classzct_1_1EventThread.html#ac7f6b59b51793ee17b868ea32a3ae63d">m_timerManager</a></td></tr>
<tr class="separator:ac7f6b59b51793ee17b868ea32a3ae63d"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><div class="compoundTemplParams">template&lt;typename EventType&gt;<br />
class zct::EventThread&lt; EventType &gt;</div><p>Use this class in your objects to create a thread that can wait for events. </p>
<p>This class spawns a new Zephyr thread.</p>
<p>The user is responsible for making sure the thread function returns if you want to destroy this object. This is because the destructor blocks until the thread is complete. The best way to do this is to implement a exit event and send it to the event thread. The event thread returns when it receives the exit event.</p>
<p>Making sure to return from the thread function is only important if you are destroying the object, e.g. in testing.</p>
<p>Below is an example of how to use this class.</p>
<div class="fragment"><div class="line"><span class="preprocessor">#include &lt;variant&gt;</span></div>
<div class="line"> </div>
<div class="line"><span class="preprocessor">#include &lt;zephyr/kernel.h&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;zephyr/logging/log.h&gt;</span></div>
<div class="line"> </div>
<div class="line"><span class="preprocessor">#include &quot;<a class="code" href="EventThread_8hpp.html">ZephyrCppToolkit/Events/EventThread.hpp</a>&quot;</span></div>
<div class="line"> </div>
<div class="line"><a class="code hl_function" href="namespacezct.html#a03e785beb455af4012d3a57e19c99d13">LOG_MODULE_REGISTER</a>(EventThreadTests, LOG_LEVEL_DBG);</div>
<div class="line"> </div>
<div class="line"><span class="comment">//================================================================================================//</span></div>
<div class="line"><span class="comment">// EVENTS</span></div>
<div class="line"><span class="comment">//================================================================================================//</span></div>
<div class="line"> </div>
<div class="line"><span class="keyword">namespace </span>Events {</div>
<div class="line"> </div>
<div class="line"><span class="keyword">struct </span>MyTimerExpiry {};</div>
<div class="line"> </div>
<div class="line"><span class="keyword">struct </span>Exit {};</div>
<div class="line"> </div>
<div class="line"><span class="keyword">struct </span>LedFlashing {</div>
<div class="line">    uint32_t flashRateMs;</div>
<div class="line">};</div>
<div class="line"> </div>
<div class="line"><span class="comment">// Create a generic event type that can be anyone of the specific events above.</span></div>
<div class="line"><span class="keyword">typedef</span> std::variant&lt;MyTimerExpiry, LedFlashing, Exit&gt; Generic;</div>
<div class="line"> </div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line"><span class="comment">//================================================================================================//</span></div>
<div class="line"><span class="comment">// EVENT THREAD</span></div>
<div class="line"><span class="comment">//================================================================================================//</span></div>
<div class="line"> </div>
<div class="line"><span class="keyword">class </span>Led : <span class="keyword">public</span> <a class="code hl_class" href="classzct_1_1EventThread.html">zct::EventThread</a>&lt;Events::Generic&gt; {</div>
<div class="line"><span class="keyword">public</span>:</div>
<div class="line">    Led() :</div>
<div class="line">        <a class="code hl_namespace" href="namespacezct.html">zct</a>::EventThread&lt;Events::Generic&gt;(</div>
<div class="line">            <span class="stringliteral">&quot;Led&quot;</span>,</div>
<div class="line">            m_threadStack,</div>
<div class="line">            THREAD_STACK_SIZE,</div>
<div class="line">            [this]() { threadMain(); },</div>
<div class="line">            7,</div>
<div class="line">            EVENT_QUEUE_NUM_ITEMS</div>
<div class="line">        ),</div>
<div class="line">        m_flashingTimer(Events::MyTimerExpiry())</div>
<div class="line">    {</div>
<div class="line">        <span class="comment">// Register timers</span></div>
<div class="line">        m_timerManager.registerTimer(m_flashingTimer);</div>
<div class="line">    }</div>
<div class="line"> </div>
<div class="line">    ~Led() {</div>
<div class="line">        <span class="comment">// Send the exit event to the event thread</span></div>
<div class="line">        Events::Exit exitEvent;</div>
<div class="line">        sendEvent(exitEvent);</div>
<div class="line">    }</div>
<div class="line"> </div>
<div class="line">    <span class="keywordtype">void</span> flash(uint32_t flashRateMs) {</div>
<div class="line">        Events::LedFlashing ledFlashingEvent = { .flashRateMs = flashRateMs };</div>
<div class="line">        sendEvent(ledFlashingEvent);</div>
<div class="line">    }</div>
<div class="line"> </div>
<div class="line"><span class="keyword">private</span>:</div>
<div class="line">    <span class="keyword">static</span> <span class="keyword">constexpr</span> <span class="keywordtype">size_t</span> EVENT_QUEUE_NUM_ITEMS = 10;</div>
<div class="line">    <span class="keyword">static</span> <span class="keyword">constexpr</span> <span class="keywordtype">size_t</span> THREAD_STACK_SIZE = 512;</div>
<div class="line">    K_KERNEL_STACK_MEMBER(m_threadStack, THREAD_STACK_SIZE);</div>
<div class="line">    <a class="code hl_class" href="classzct_1_1Timer.html">zct::Timer&lt;Events::Generic&gt;</a> m_flashingTimer;</div>
<div class="line">    <span class="keywordtype">bool</span> m_ledIsOn = <span class="keyword">false</span>;</div>
<div class="line"> </div>
<div class="line">    <span class="keywordtype">void</span> threadMain() {</div>
<div class="line">        <span class="keywordflow">while</span> (1) {</div>
<div class="line">            Events::Generic <span class="keyword">event</span> = <a class="code hl_function" href="classzct_1_1EventThread.html#a2607651cb659eb7d0c1beb81a7690293">zct::EventThread&lt;Events::Generic&gt;::waitForEvent</a>();</div>
<div class="line">            <span class="keywordflow">if</span> (std::holds_alternative&lt;Events::MyTimerExpiry&gt;(event)) {</div>
<div class="line">                LOG_INF(<span class="stringliteral">&quot;Toggling LED to %d.&quot;</span>, !m_ledIsOn);</div>
<div class="line">                m_ledIsOn = !m_ledIsOn;</div>
<div class="line">            } <span class="keywordflow">else</span> <span class="keywordflow">if</span> (std::holds_alternative&lt;Events::LedFlashing&gt;(event)) {</div>
<div class="line">                <span class="comment">// Start the timer to flash the LED</span></div>
<div class="line">                m_flashingTimer.<a class="code hl_function" href="classzct_1_1Timer.html#ac2642b147eeb4ebbe126ac70f10ac7be">start</a>(1000, 1000);</div>
<div class="line">                LOG_INF(<span class="stringliteral">&quot;Starting flashing. Turning LED on...&quot;</span>);</div>
<div class="line">                m_ledIsOn = <span class="keyword">true</span>;</div>
<div class="line">            } <span class="keywordflow">else</span> <span class="keywordflow">if</span> (std::holds_alternative&lt;Events::Exit&gt;(event)) {</div>
<div class="line">                <span class="keywordflow">break</span>;</div>
<div class="line">            }</div>
<div class="line">        }</div>
<div class="line">    }</div>
<div class="line">};</div>
<div class="line"> </div>
<div class="line"><span class="keywordtype">int</span> main() {</div>
<div class="line">    Led led;</div>
<div class="line"> </div>
<div class="line">    <span class="comment">// Start the LED flashing. The flashing will happen</span></div>
<div class="line">    <span class="comment">// in the LED event thread.</span></div>
<div class="line">    led.flash(1000);</div>
<div class="line"> </div>
<div class="line">    <span class="comment">// Wait 2.5s. The LED should flash twice in this time.</span></div>
<div class="line">    k_sleep(K_MSEC(2500));</div>
<div class="line">}</div>
<div class="ttc" id="aEventThread_8hpp_html"><div class="ttname"><a href="EventThread_8hpp.html">EventThread.hpp</a></div></div>
<div class="ttc" id="aclasszct_1_1EventThread_html"><div class="ttname"><a href="classzct_1_1EventThread.html">zct::EventThread</a></div><div class="ttdoc">Use this class in your objects to create a thread that can wait for events.</div><div class="ttdef"><b>Definition</b> EventThread.hpp:34</div></div>
<div class="ttc" id="aclasszct_1_1EventThread_html_a2607651cb659eb7d0c1beb81a7690293"><div class="ttname"><a href="classzct_1_1EventThread.html#a2607651cb659eb7d0c1beb81a7690293">zct::EventThread::waitForEvent</a></div><div class="ttdeci">EventType waitForEvent()</div><div class="ttdef"><b>Definition</b> EventThread.hpp:113</div></div>
<div class="ttc" id="aclasszct_1_1Timer_html"><div class="ttname"><a href="classzct_1_1Timer.html">zct::Timer</a></div><div class="ttdoc">A timer that can be used to fire events at a regular interval in an event driven application.</div><div class="ttdef"><b>Definition</b> Timer.hpp:39</div></div>
<div class="ttc" id="aclasszct_1_1Timer_html_ac2642b147eeb4ebbe126ac70f10ac7be"><div class="ttname"><a href="classzct_1_1Timer.html#ac2642b147eeb4ebbe126ac70f10ac7be">zct::Timer::start</a></div><div class="ttdeci">void start(int64_t period_ms)</div><div class="ttdef"><b>Definition</b> Timer.hpp:61</div></div>
<div class="ttc" id="anamespacezct_html"><div class="ttname"><a href="namespacezct.html">zct</a></div><div class="ttdef"><b>Definition</b> Mutex.hpp:6</div></div>
<div class="ttc" id="anamespacezct_html_a03e785beb455af4012d3a57e19c99d13"><div class="ttname"><a href="namespacezct.html#a03e785beb455af4012d3a57e19c99d13">zct::LOG_MODULE_REGISTER</a></div><div class="ttdeci">LOG_MODULE_REGISTER(EventThread, LOG_LEVEL_DBG)</div></div>
</div><!-- fragment --> </div><h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a id="ae5fff68f935d3dc1b0a7043232b54eeb" name="ae5fff68f935d3dc1b0a7043232b54eeb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae5fff68f935d3dc1b0a7043232b54eeb">&#9670;&#160;</a></span>EventThread()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename EventType &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classzct_1_1EventThread.html">zct::EventThread</a>&lt; EventType &gt;::EventThread </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">k_thread_stack_t *&#160;</td>
          <td class="paramname"><em>threadStack</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>threadStackSize</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::function&lt; void()&gt;&#160;</td>
          <td class="paramname"><em>threadFunction</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>threadPriority</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>eventQueueBufferNumItems</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Create a new event thread.</p>
<p>Dynamically allocates memory for the event queue buffer. At the moment, you have to allocate the thread stack yourself and pass it in. Once Zephyr's dynamic thread support is out of experimental (and working), hopefully we can just pass in the desired stack size.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">name</td><td>The name of the this event thread. Used for logging purposes. The Zephyr thread name will also be set to this name. </td></tr>
    <tr><td class="paramname">threadStack</td><td>The stack to use for the thread. You can use <code>K_KERNEL_STACK_MEMBER(m_threadStack, THREAD_STACK_SIZE);</code> to declare a stack member in the parent class that encloses this event thread. </td></tr>
    <tr><td class="paramname">threadStackSize</td><td>The size of the stack provided. </td></tr>
    <tr><td class="paramname">threadFunction</td><td>The function to call when the thread is started. This should do whatever setup you need and then call <a class="el" href="classzct_1_1EventThread.html#a2607651cb659eb7d0c1beb81a7690293">waitForEvent()</a>. </td></tr>
    <tr><td class="paramname">threadPriority</td><td>The priority to assign to the thread. </td></tr>
    <tr><td class="paramname">eventQueueBufferNumItems</td><td>The number of items in the event queue. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a904626047be03e08a6563cdafb3582c0" name="a904626047be03e08a6563cdafb3582c0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a904626047be03e08a6563cdafb3582c0">&#9670;&#160;</a></span>~EventThread()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename EventType &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classzct_1_1EventThread.html">zct::EventThread</a>&lt; EventType &gt;::~<a class="el" href="classzct_1_1EventThread.html">EventThread</a> </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Destroy the event thread. This will block until the thread has exited.</p>
<p>If you want this function to return, make sure you make the thread function return. See <a class="el" href="classzct_1_1EventThread.html">EventThread</a> for more details. </p>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a id="a6eda66c2494c12922204a368786dfb73" name="a6eda66c2494c12922204a368786dfb73"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6eda66c2494c12922204a368786dfb73">&#9670;&#160;</a></span>sendEvent()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename EventType &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classzct_1_1EventThread.html">zct::EventThread</a>&lt; EventType &gt;::sendEvent </td>
          <td>(</td>
          <td class="paramtype">const EventType &amp;&#160;</td>
          <td class="paramname"><em>event</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Send an event to this event thread. This can be called from any other thread to send an event to this event thread.</p>
<dl class="section note"><dt>Note</dt><dd>This function is thread safe. </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">event</td><td>The event to send. It is copied into the event queue so it's lifetime only needs to be as long as this function call. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ad9ef1d2f6b589be97f8a27c632278d2b" name="ad9ef1d2f6b589be97f8a27c632278d2b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad9ef1d2f6b589be97f8a27c632278d2b">&#9670;&#160;</a></span>staticThreadFunction()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename EventType &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void <a class="el" href="classzct_1_1EventThread.html">zct::EventThread</a>&lt; EventType &gt;::staticThreadFunction </td>
          <td>(</td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>arg1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>arg2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>arg3</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>The function needed by pass to Zephyr's thread API </p>

</div>
</div>
<a id="a62e7cf1cb3a1fe3fb0fd531d35493287" name="a62e7cf1cb3a1fe3fb0fd531d35493287"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a62e7cf1cb3a1fe3fb0fd531d35493287">&#9670;&#160;</a></span>timerManager()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename EventType &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classzct_1_1TimerManager.html">TimerManager</a>&lt; EventType &gt; &amp; <a class="el" href="classzct_1_1EventThread.html">zct::EventThread</a>&lt; EventType &gt;::timerManager </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Call to get the timer manager for this event thread. This is useful when you want to create timers and then register them with the event thread.</p>
<p>Typically you would call:</p>
<div class="fragment"><div class="line">myEventThread.timerManager().registerTimer(myTimer);</div>
</div><!-- fragment --><dl class="section return"><dt>Returns</dt><dd>A reference to the timer manager for this event thread. </dd></dl>

</div>
</div>
<a id="a2607651cb659eb7d0c1beb81a7690293" name="a2607651cb659eb7d0c1beb81a7690293"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2607651cb659eb7d0c1beb81a7690293">&#9670;&#160;</a></span>waitForEvent()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename EventType &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">EventType <a class="el" href="classzct_1_1EventThread.html">zct::EventThread</a>&lt; EventType &gt;::waitForEvent </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Call to block and wait for an event. An event can either be:</p><ul>
<li>A internal timer timeout event.</li>
<li>An external event (sent from another thread).</li>
</ul>
<p>This should be called from the thread function that is passed in to the constructor, once any initialisation you want done (e.g. setup some timers) has been done.</p>
<dl class="section return"><dt>Returns</dt><dd>The event that was received. This should be handled in your thread function and then loop back to <code><a class="el" href="classzct_1_1EventThread.html#a2607651cb659eb7d0c1beb81a7690293">waitForEvent()</a></code> to wait for the next event. </dd></dl>

</div>
</div>
<h2 class="groupheader">Member Data Documentation</h2>
<a id="a63d260fa7951c1731953b2f89cb8c794" name="a63d260fa7951c1731953b2f89cb8c794"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a63d260fa7951c1731953b2f89cb8c794">&#9670;&#160;</a></span>m_eventQueueBuffer</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename EventType &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void* <a class="el" href="classzct_1_1EventThread.html">zct::EventThread</a>&lt; EventType &gt;::m_eventQueueBuffer = nullptr</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a2445c0ef143d1ecece52db6354c1a3c6" name="a2445c0ef143d1ecece52db6354c1a3c6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2445c0ef143d1ecece52db6354c1a3c6">&#9670;&#160;</a></span>m_name</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename EventType &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const char* <a class="el" href="classzct_1_1EventThread.html">zct::EventThread</a>&lt; EventType &gt;::m_name = nullptr</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="ae99f50e4328cdd741e63e379fbe7de6a" name="ae99f50e4328cdd741e63e379fbe7de6a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae99f50e4328cdd741e63e379fbe7de6a">&#9670;&#160;</a></span>m_thread</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename EventType &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">struct k_thread <a class="el" href="classzct_1_1EventThread.html">zct::EventThread</a>&lt; EventType &gt;::m_thread</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="af82899498638998526e3118fded52e0c" name="af82899498638998526e3118fded52e0c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af82899498638998526e3118fded52e0c">&#9670;&#160;</a></span>m_threadFunction</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename EventType &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::function&lt;void()&gt; <a class="el" href="classzct_1_1EventThread.html">zct::EventThread</a>&lt; EventType &gt;::m_threadFunction</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="aeac1a315e79be599f6c6c8e275c7286a" name="aeac1a315e79be599f6c6c8e275c7286a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aeac1a315e79be599f6c6c8e275c7286a">&#9670;&#160;</a></span>m_threadMsgQueue</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename EventType &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">struct k_msgq <a class="el" href="classzct_1_1EventThread.html">zct::EventThread</a>&lt; EventType &gt;::m_threadMsgQueue</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="ac7f6b59b51793ee17b868ea32a3ae63d" name="ac7f6b59b51793ee17b868ea32a3ae63d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac7f6b59b51793ee17b868ea32a3ae63d">&#9670;&#160;</a></span>m_timerManager</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename EventType &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classzct_1_1TimerManager.html">TimerManager</a>&lt;EventType&gt; <a class="el" href="classzct_1_1EventThread.html">zct::EventThread</a>&lt; EventType &gt;::m_timerManager</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<hr/>The documentation for this class was generated from the following file:<ul>
<li>/home/runner/work/ZephyrCppToolkit/ZephyrCppToolkit/include/ZephyrCppToolkit/Events/<a class="el" href="EventThread_8hpp_source.html">EventThread.hpp</a></li>
</ul>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="navelem"><a class="el" href="namespacezct.html">zct</a></li><li class="navelem"><a class="el" href="classzct_1_1EventThread.html">EventThread</a></li>
    <li class="footer">Generated by <a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.8 </li>
  </ul>
</div>
</body>
</html>
